# 로또 구매 및 당첨 관리 구조 논리 설계서 (Lottery Data Architecture)

사용자의 로또 구매 내역, 당첨 결과, 그리고 **사용자의 결과 확인 여부**를 체계적으로 관리하기 위한 논리적 데이터베이스 구성 및 처리 로직입니다.

## 1. 개요
* **목적**: 사용자의 전체 구매 내역을 기록하고, 당첨 발표에 맞춰 정확한 검증 및 통계를 자동 산출. 특히 **사용자가 아직 확인하지 않은 결과**와 **확인 완료된 결과**를 명확히 구분하여 보여주기 위함.
* **핵심 관리 요소**: 구매 내역(티켓별), 공식 당첨 회차 정보, 상태 관리 (당첨 결과 확인 전/후), 통계 지표

## 2. 논리적 데이터 구조 (ERD Schema)

기존 단일 `purchases` 구조를 확장하여 로직을 구성합니다. 공식 당첨 정보를 저장하기 위한 `Rounds` 엔티티와, 실제 사용자 구매 내역을 저장하는 `Purchases` 엔티티로 데이터를 추상화합니다.

### 2.1 [엔티티 A] Rounds (회차별 공식 결과)
공식적인 로또 회차 및 당첨 결과를 보관하는 기준 정보입니다.
- **round_number** (PK, Integer): 로또 회차 (예: 1100)
- **draw_date** (Date): 공식 추첨 일자
- **winning_numbers** (String): 1등 당첨 번호 6개 (JSON or 콤마 문자열)
- **bonus_number** (Integer): 보너스 번호
- **is_drawn** (Boolean): 당첨 발표(추첨 완료) 여부. (발표 전 `False`, 발표 후 `True`)

### 2.2 [엔티티 B] Purchases (사용자 구매 티켓 이력)
사용자가 1000원을 주고 구매한 "하나의 게임(1 Line)" 단위입니다. 핵심은 **`is_user_checked`** 컬럼을 통해 사용자가 직접 결과를 확인했는지를 추적하는 것입니다.
- **id** (PK, Integer): 고유 키
- **round_number** (FK, Integer): 구매한 로또 회차
- **purchase_date** (Datetime): 사용자의 실제 구매 일자
- **numbers** (String): 사용자가 선택한/발급받은 6개 번호 
- **mode** (String): 구매 방식 (수동, 반자동, 자동)
- **cost** (Integer): 티켓 단가 (기본 1000)
- **win_rank** (String/Enum): 1등~5등, 낙첨, 대기중 (시스템이 채점한 결과)
- **win_amount** (Integer): 획득한 당첨 금액
- **is_user_checked** (Boolean): **사용자의 결과 확인 여부 플래그** (기본값 `False`. 사용자가 "미확인 결과"를 조회하는 순간 `True`로 업데이트)

---

## 3. 요구사항별 데이터 매핑 및 통계 산출 로직

### 3.1 미확인 결과 보기 (Unchecked Results View)
**목표**: 시스템이 당첨 결과를 채점했으나, 사용자가 "아직 보지 않은" 결과만 모아서 보여주고, 보는 순간 "확인 완료" 처리.
* **조회 조건**: `Purchases` + `Rounds` 조인. `Rounds.is_drawn = True` (추첨은 완료됨) AND `Purchases.is_user_checked = False` (사용자가 아직 안 봄).
* **표시 지표**:
  * 미확인 게임의 총 구매 횟수 (Total Unchecked Games)
  * 미확인 게임 중 랭크별 당첨 횟수 (1등 N번, 5등 M번 등)
  * 미확인 게임의 총 당첨액 합계 (`SUM(win_amount)`)
  * 미확인 게임의 총 지출액 합계 (`SUM(cost)`)
* **상태 업데이트 로직 (핵심)**: 해당 내역을 사용자에게 보여준 직후, 조회된 모든 `Purchases` 레코드의 **`is_user_checked`를 `True`로 일괄 업데이트(UPDATE) 합니다.**

### 3.2 전체 결과 내역 보기 (All Checked Results View)
**목표**: 과거에 사용자가 이미 한 번 이상 확인했던 모든 결과들의 누적 통계를 보여줍니다.
* **조회 조건**: `Purchases.is_user_checked = True`
* **표시 지표**:
  * 확인 완료된 게임의 총 구매 횟수
  * 확인 완료된 게임 중 랭크별 당첨 횟수 누적
  * 확인 완료된 게임의 총 누적 당첨액
  * 확인 완료된 게임의 총 누적 지출액
  * (선택) 전체 순수익 금액 (`총 누적 당첨액` - `총 누적 지출액`)

### 3.3 회차별 상세 결과 세분화 (Rounding Details)
단순 통계뿐만 아니라 특정 회차의 내가 산 번호와 당첨된 번호를 비교.
- 기능: "1100회차 결과 보기"
- 조회 내역: 
  - 내가 구매한 번호 리스트 (`Purchases.numbers`)
  - 각 번호의 당첨 등수와 금액 (`Purchases.win_rank`, `win_amount`)
  - 그 회차의 공식 당첨 번호 (`Rounds.winning_numbers`)

---

## 4. 라이프사이클 (상태 변화 플로우 적용)

1. **[구매 단계]**: 티켓 구매 정보 DB 저장. `win_rank='대기중'`, `is_user_checked=False`.
2. **[시스템 채점 단계]**: 토요일 추첨 완료 후, 시스템(백그라운드 등)이 당첨 번호를 가져와 `Rounds`에 저장하고, 모든 '대기중' 티켓의 당첨금액과 랭크를 계산해 업데이트. (단, `is_user_checked`는 여전히 `False`)
3. **[사용자 미확인 내역 접속]**:
   - `is_user_checked=False`인 데이터들을 불러와 화면(또는 CLI 알림)에 보여줌. (예: "축하합니다! 새로운 당첨 결과가 있습니다. 5등 1번!")
   - 화면에 뿌려줌과 동시에 DB에서 해당 레코드들을 `is_user_checked = True`로 업데이트 실행.
4. **[사용자 전체 내역 접속]**: 
   - `is_user_checked=True` 인 모든 데이터를 불러와 역대 나의 누적 통계/성적을 확인.

---

## 5. 추가로 고려하면 좋은 관리 항목 제안 (추천)

단순 조회 외에 더 재미있고 유용한 분석을 위해 다음 컬럼/기능 추가를 고려해 볼 수 있습니다.

1. **`purchase_place` (구매처 정보 컬럼)**
   - 온라인 100% 구매라면 상관없으나, 추후 오프라인으로 구매한 내역도 수기 입력할 경우, **구입처(온라인/명당 오프라인 등)**를 남겨두면 "어디서 샀을 때 당첨이 잘 되나" 통계가 가능해집니다.
2. **`mode_stats` (구매 방식별 통계 기능)**
   - 이미 `mode`(자동/수동) 컬럼이 있으니, *전체 통계 화면*에서 **수동 구매로 당첨된 비율 vs 자동 구매로 당첨된 비율 비교 지표**를 보여주면 흥미롭습니다.
3. **`ROI` 계산 컬럼 혹은 로직 (수익률)**
   - 누적 당첨액 / 누적 지출액 * 100을 통한 **내 생애 로또 수익률(%)** 지표. 
4. **번호 출현 빈도 분석 (User Number Stats)**
   - 내가 '수동'으로 자주 찍는 번호 중 어느 번호가 가장 많이 당첨되었나(혹은 낙첨되었나) 분석해주는 커스텀 통계 항목.
